# OOD_Assignment2

به نام خدا

تمرین شماره 2: آشنایی با الگوهای طراحی
| شماره دانشجویی | نام دانشجو |
| :---: | :---: |
| 4022170125 | فاطمه محجوب |
| 4022170126 | رضوان محمدی |

# **بخش اول: تشخیص زیرمسائل و الگوها**



### **1. مدیریت وضعیت‌هاي درخواست(Lifecycle)** 


• شرح مسئله: در کد فعلی، یک رشته (String Status) براي نگهداري وضعیت تیکت استفاده شده و در متد handle، با استفاده از دستورات ifمتعدد، بررسی می‌شود که وضعیت فعلی چیست تا عملیات بعدي انجام شود. این کار باعث ایجاد دستورات شرطی طولانی و مدیریت سخت تغیر وضعیت‌ها می‌شود. رفتار سیستم در وضعیت‌هاي «ایجاد شد»، «ارجاع داده شد»، «در حال رسیدگی» و... متفاوت است.


• الگوي پیشنهادي:  State Pattern ( الگوي وضعیت)


• دلیل: وقتی رفتار یک آبجکت وابسته به حالت (State) آن است و باید در زمان اجرا تغییر کند، و همچنین میخواهیم از ifهاي تو در تو و طولانی دوري کنیم، الگوي State بهترین گزینه است. این الگو به ما اجازه میدهد هر وضعیت را به عنوان یک کلاس جداگانه پیاده‌سازي کنیم و تغییر وضعیت را به آبجکت‌هاي وضعیت واگذار کنیم.


• روش اعمال:

- یک اینترفیس به نام TicketStateتعریف می‌کنیم که متدي مثل ()handleدارد.
- براي هر وضعیت (Closed ,Resolved ,InProgress ,Assigned ,New) یک کلاس جداگانه می‌سازیم که این اینترفیس را پیاده‌سازي می‌کند.
- کلاس Ticketبه جاي نگهداري یک رشته، یک ارجاع به TicketStateنگه می‌دارد. فراخوانی متد handleدر تیکت، به کلاس وضعیت فعلی واگذار (Delegate) می‌شود.
  <br><br>

### **2. نحوه رسیدگی و پاسخدهی براساس نوع درخواست**

• شرح مسئله: در بخش‌هایی از کد (مثلاً وقتی وضعیت ASSIGNED یا IN_PROGRESS است)، بر اساس نوع تیکت (BUG یا سایر موارد)، واحد مسئول یا نوع پاسخ متفاوت است. در کد فعلی این بررسی با دستور if (type.equals("BUG")) انجام شده است. اگر بخواهیم نوع جدیدي  اضافه کنیم، باید کدهاي اصلی را تغییر دهیم.

• الگوي پیشنهادي: Strategy Patern (الگوي استراتژي) 

• دلیل: وقتی می خواهیم به یک هدف برسیم ولی پیاده سازی و الگوریتم‌های متفاوتی وجود دارند(اینجا روش رسیدگی/پاسخدهی) و باید در زمان اجرا یکی از آن الگوریتم ها را انتخاب کنیم، از الگوي Strategy استفاده می‌کنیم. این کار باعث حذف دستورات شرطی مربوط به نوع تیکت می‌شود.

• روش اعمال:
- یک اینترفیس به نام HandlingStrategy تعریف می‌کنیم که متدهایی براي assign (ارجاع به واحد) و respond (ارسال پاسخ) دارد.
- دو کلاس استراتژي میسازیم: BugHandlingStrategy وGeneralHandlingStrategy

ساختار متدهای اینترفیس HandlingStrategy: برای پوشش کامل چرخه حیات یک تیکت، این اینترفیس دارای دو متد کلیدی است که در مراحل مختلف فراخوانی می‌شوند:<br>
متد assign() (مرحله ارجاع):<br>
کاربرد: این متد در وضعیت AssignedState فراخوانی می‌شود.<br>
دلیل: هر نوع تیکت باید به واحد مربوطه ارجاع شود. مثلاً در BugHandlingStrategy تیکت به "تیم فنی" و در GeneralHandlingStrategy به "تیم پشتیبانی" ارجاع داده می‌شود. این متد تضمین می‌کند که منطق «به چه کسی ارجاع شود» از کلاس تیکت جدا شود.
<br>
متد respond() (مرحله پاسخ‌دهی):<br>
کاربرد: این متد در وضعیت InProgressState فراخوانی می‌شود.<br>
دلیل: پس از بررسی، نوع پاسخ به کاربر متفاوت است. برای یک باگ، پاسخ "Sending bug response" است، اما برای درخواست‌های عمومی، پاسخ "Sending generic response" می‌باشد. این متد منطق «چگونه پاسخ داده شود» را مدیریت می‌کند.
<br><br>

### **3. ایجاد آبجکت‌هاي تیکت بر اساس کانال ورودی** 

• شرح مسئله: در کد Main، آبجکت Ticket به صورت مستقیم با new ساخته می‌شود. اگر بخواهیم منطق پیچیده‌اي براي ایجاد تیکت داشته باشیم، یا بخواهیم نوع تیکت را در لحظه ساخت تعیین کنیم، کلاس Main درگیر جزئیات ساخت می‌شود.

• الگوي پیشنهادي: Factory Patern (الگوي کارخانه) 

• دلیل: براي جدا کردن منطق ایجاد آبجکت‌ها از کلاینت و مدیریت پیچیدگی‌هاي ساخت مرحله به مرحله، از الگوي Factory استفاده می‌کنیم. این کار باعث می‌شود کلاینت (Main) نداند چگونه یک تیکت ساخته می‌شود، فقط درخواست می‌دهد.

• روش اعمال:<br>
- یک کلاس TicketFactoryمی سازیم به عنوان مرکز مدیریت عمل می‌کند و با بررسی درخواست کلاینت (نوع کانال)، تصمیم می‌گیرد مسئولیتِ نهاییِ ساخت را به کدام زیرکلاس واگذار کند.<br>
- زیرکلاس‌های WebTicketFactory و EmailTicketFactory: هر کلاس مسئولیتِ نمونه‌سازیِ واقعیِ تیکت را بر عهده دارد.<br>
    چاپ پیام‌های شناسایی (مانند Received from web/email) در Constructor زیرکلاس‌ها قرار گرفته است؛ بنابراین به محض انتخابِ کلاس توسط فکتوری، هویت آن اعلام می‌شود.
