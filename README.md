# OOD_Assignment2

به نام خدا

تمرین شماره 2: آشنایی با الگوهای طراحی
| شماره دانشجویی | نام دانشجو |
| :---: | :---: |
| 4022170125 | فاطمه محجوب |
| 4022170126 | رضوان محمدی |

# **بخش اول: تشخیص زیرمسائل و الگوها**



### **1. مدیریت وضعیت‌هاي درخواست(Lifecycle)** 


• شرح مسئله: در کد فعلی، یک رشته (String Status) براي نگهداري وضعیت تیکت استفاده شده و در متد handle، با استفاده از دستورات ifمتعدد، بررسی می‌شود که وضعیت فعلی چیست تا عملیات بعدي انجام شود. این کار باعث ایجاد دستورات شرطی طولانی و مدیریت سخت تغیر وضعیت‌ها می‌شود. رفتار سیستم در وضعیت‌هاي «ایجاد شد»، «ارجاع داده شد»، «در حال رسیدگی» و... متفاوت است.


• الگوي پیشنهادي:  State Pattern ( الگوي وضعیت)


• دلیل: وقتی رفتار یک آبجکت وابسته به حالت (State) آن است و باید در زمان اجرا تغییر کند، و همچنین میخواهیم از ifهاي تو در تو و طولانی دوري کنیم، الگوي State بهترین گزینه است. این الگو به ما اجازه میدهد هر وضعیت را به عنوان یک کلاس جداگانه پیاده‌سازي کنیم و تغییر وضعیت را به آبجکت‌هاي وضعیت واگذار کنیم.


• روش اعمال:

- یک اینترفیس به نام TicketStateتعریف می‌کنیم که متدي مثل ()handleدارد.
- براي هر وضعیت (Closed ,Resolved ,InProgress ,Assigned ,New) یک کلاس جداگانه می‌سازیم که این اینترفیس را پیاده‌سازي می‌کند.
- کلاس Ticketبه جاي نگهداري یک رشته، یک ارجاع به TicketStateنگه می‌دارد. فراخوانی متد handleدر تیکت، به کلاس وضعیت فعلی واگذار (Delegate) می‌شود.
  <br><br>
### **2. نحوه رسیدگی و پاسخدهی براساس نوع درخواست**

• شرح مسئله: در بخش‌هایی از کد (مثلاً وقتی وضعیت ASSIGNED یا IN_PROGRESS است)، بر اساس نوع تیکت (BUG یا سایر موارد)، واحد مسئول یا نوع پاسخ متفاوت است. در کد فعلی این بررسی با دستور if (type.equals("BUG")) انجام شده است. اگر بخواهیم نوع جدیدي  اضافه کنیم، باید کدهاي اصلی را تغییر دهیم.

• الگوي پیشنهادي: Strategy Patern (الگوي استراتژي) 

• دلیل: وقتی می خواهیم به یک هدف برسیم ولی پیاده سازی و الگوریتم‌های متفاوتی وجود دارند(اینجا روش رسیدگی/پاسخدهی) و باید در زمان اجرا یکی از آن الگوریتم ها را انتخاب کنیم، از الگوي Strategy استفاده می‌کنیم. این کار باعث حذف دستورات شرطی مربوط به نوع تیکت می‌شود.

• روش اعمال:
- یک اینترفیس به نام HandlingStrategy تعریف می‌کنیم که متدهایی براي assign (ارجاع به واحد) و respond (ارسال پاسخ) دارد.
- دو کلاس استراتژي میسازیم: BugHandlingStrategy وGeneralHandlingStrategy

ساختار متدهای اینترفیس HandlingStrategy: برای پوشش کامل چرخه حیات یک تیکت، این اینترفیس دارای دو متد کلیدی است که در مراحل مختلف فراخوانی می‌شوند:<br>
- متد assign() (مرحله ارجاع): <br>
کاربرد: این متد در وضعیت AssignedState فراخوانی می‌شود.<br>
دلیل: هر نوع تیکت باید به واحد مربوطه ارجاع شود. مثلاً در BugHandlingStrategy تیکت به "تیم فنی" و در GeneralHandlingStrategy به "تیم پشتیبانی" ارجاع داده می‌شود. این متد تضمین می‌کند که منطق «به چه کسی ارجاع شود» از کلاس تیکت جدا شود.<br>
- متد respond() (مرحله پاسخ‌دهی): <br>
کاربرد: این متد در وضعیت InProgressState فراخوانی می‌شود.<br>
دلیل: پس از ارجاع دادن به واحد مربوطه، نوع پاسخ به کاربر متفاوت است. برای یک باگ، پاسخ "Sending bug response" است، اما برای درخواست‌های عمومی، پاسخ "Sending generic response" می‌باشد. این متد منطق «چگونه پاسخ داده شود» را مدیریت می‌کند.<br>
<br><br>
### **3. ایجاد آبجکت‌هاي تیکت بر اساس کانال ورودی** 

• شرح مسئله: در کد Main، آبجکت Ticket به صورت مستقیم با new ساخته می‌شود. اگر بخواهیم منطق پیچیده‌اي براي ایجاد تیکت داشته باشیم، یا بخواهیم نوع تیکت را در لحظه ساخت تعیین کنیم، کلاس Main درگیر جزئیات ساخت می‌شود.

• الگوي پیشنهادي: Factory Patern (الگوي کارخانه) 

• دلیل: براي جدا کردن منطق ایجاد آبجکت‌ها از کلاینت و مدیریت پیچیدگی‌هاي ساخت مرحله به مرحله، از الگوي Factory استفاده می‌کنیم. این کار باعث می‌شود کلاینت (Main) نداند چگونه یک تیکت ساخته می‌شود، فقط درخواست می‌دهد.

• روش اعمال:<br>
- یک کلاس TicketFactoryمی سازیم به عنوان مرکز مدیریت عمل می‌کند و با بررسی درخواست کلاینت (نوع کانال)، تصمیم می‌گیرد مسئولیتِ نهاییِ ساخت را به کدام زیرکلاس واگذار کند.<br>
- زیرکلاس‌های WebTicketFactory و EmailTicketFactory: هر کلاس مسئولیتِ نمونه‌سازیِ واقعیِ تیکت را بر عهده دارد.<br>
- چاپ پیام‌های شناسایی (مانند Received from web/email) در Constructor زیرکلاس‌ها قرار گرفته است؛ بنابراین به محض انتخابِ کلاس توسط فکتوری، هویت آن اعلام می‌شود.




# **بخش دوم: ترسیم Class Diagram**



لینک تصویر Class Diagram:

https://github.com/Rzvn-mhmdi/OOD_Assignment2/blob/17ed1289491ffe6d9517323c6012ae96670b86b3/ticket-class-diagram.png




# **بخش سوم: اعمال الگو**



### **۱. پیاده‌سازی الگوی طراحی وضعیت (State Pattern)**

برای مدیریت چرخه حیات تیکت، از اینترفیس TicketState و کلاس‌های پیاده‌ساز آن استفاده شده است:

کد TicketState.java: تعریف یک قرارداد واحد برای تمام وضعیت‌ها با متد handle(Ticket ticket).

کد NewState.java: مسئول چاپ پیام ایجاد تیکت و انتقال به وضعیت AssignedState.

کد AssignedState.java: با استفاده از استراتژی تعیین شده، عمل تخصیص را انجام داده و به وضعیت InProgressState می‌رود.

کد InProgressState.java: عملیات پاسخگویی را از طریق استراتژی اجرا کرده و تیکت را به ResolvedState منتقل می‌کند.

کد ResolvedState.java: پیام Resolvede را چاپ می‌کند و تیکت را به ClosedState منتقل می‌کند. 

کد ClosedState.java: مرحله نهایی که عملیات لاگ‌گیری پایان کار را انجام می‌دهد.

تغییرات در کد Ticket:
در کد قدیمی، نوع تیکت (مثلاً BUG) با شرط‌های ساده بررسی می‌شد.

در کد جدید به جای اینکه تیکت بداند «چگونه» کارها را انجام دهد، یک شیء استراتژی (private HandlingStrategy strategy) را در خود نگه می‌دارد. متد setStrategy به فکتوری اجازه می‌دهد تا در لحظه ساخت، ابزار مناسب (مثلاً BugHandlingStrategy) را به تیکت تزریق کند و متد getStrategy به کلاس‌هایی مثل AssignedState اجازه می‌دهد تا بدون درگیر شدن با نوع تیکت، دستور assign() را از داخل آن استراتژی فراخوانی کنند
<br><br>
### **۲. پیاده‌سازی الگوی طراحی استراتژی (Strategy Pattern)**

تعریف اینترفیس HandlingStrategy با دو متد کلیدی assign, respond:

در کد قدیمی، TicketService باید می‌دانست هر نوع تیکت به کجا ارجاع شود و چه پاسخی بگیرد. با دو متد assign و respond در استراتژی، تیکت خودش می‌داند در هر مرحله چه رفتاری نشان دهد.<br>
متد assign(): برای مدیریت منطق ارجاع تیکت. این متد جایگزین if (type.equals("BUG")) در مرحله ASSIGNED کد قدیمی شد.<br>
متد respond(): برای مدیریت منطق پاسخ‌دهی. این متد جایگزین شرط‌های مربوط به چاپ پیام پاسخ در مرحله IN_PROGRESS شد.


ایجاد کلاس‌های BugHandlingStrategy و GeneralHandlingStrategy:
انتقال پیام‌های چاپی اختصاصی (مثل "Assigned to engineering" یا "Sending bug response") به داخل این کلاس‌ها
<br><br>
### **۳. پیاده‌سازی الگوی طراحی فکتوری (Factory Method)**

ایجاد کلاس TicketFactory:
<br>
کلاس فکتوری به این دلیل اضافه شد که مسئولیت تصمیم‌گیری برای ایجاد اشیاء را از کلاس Main بردارد. با این کار، لایه اجرایی برنامه دیگر درگیر جزئیات ساختار داخلی تیکت‌ها نمی‌شود.

ایجاد زیرکلاس‌های Email/WebTicketFactory:
<br>
این زیرکلاس‌ها وظیفه دارند پس از تصمیم‌گیری فکتوری درباره نوع درخواست، شیء تیکت مربوط به آن کانال را بسازند. همچنین وظیفه چاپ پیام‌های اطلاع‌رسانی (Received from email/web) به این کلاس‌ها واگذار شده است.<br>
کد مربوط به بررسی نوع تیکت type.equalsIgnoreCase("BUG") در هر دو زیرکلاس تکرار شده است تا اطمینان حاصل شود که هر تیکت بلافاصله پس از ساخته شدن، به استراتژی صحیح (Bug/General) تخصیص داده می‌شود تا در مراحل بعدی پردازش (AssignedState و  InProgressState)، تیکت بدون خطا عمل کند.
<br><br>
### **۴. تغییرات در کلاس Main**
برای سازگاری با ساختار جدید و الگوهای طراحی اضافه شده، تغییر زیر در کلاس Main اعمال شد: <br>
نمونه‌سازی مستقیم تیکت با دستور new حذف شد و به جای آن، از متد createTicket در کلاس فکتوری استفاده شد.
