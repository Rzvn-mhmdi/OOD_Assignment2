# OOD_Assignment2

به نام خدا

تمرین شماره 2: آشنایی با الگوهای طراحی
| شماره دانشجویی | نام دانشجو |
| :---: | :---: |
| 4022170125 | فاطمه محجوب |
| 4022170126 | رضوان محمدی |

# **بخش اول: تشخیص زیرمسائل و الگوها**



### **1. مدیریت وضعیت‌هاي درخواست(Lifecycle)** 


• شرح مسئله: در کد فعلی، یک رشته (String Status) براي نگهداري وضعیت تیکت استفاده شده و در متد handle، با استفاده از دستورات ifمتعدد، بررسی می‌شود که وضعیت فعلی چیست تا عملیات بعدي انجام شود. این کار باعث ایجاد دستورات شرطی طولانی و مدیریت سخت تغیر وضعیت‌ها می‌شود. رفتار سیستم در وضعیت‌هاي «ایجاد شد»، «ارجاع داده شد»، «در حال رسیدگی» و... متفاوت است.


• الگوي پیشنهادي:  State Pattern ( الگوي وضعیت)


• دلیل: وقتی رفتار یک آبجکت وابسته به حالت (State) آن است و باید در زمان اجرا تغییر کند، و همچنین میخواهیم از ifهاي تو در تو و طولانی دوري کنیم، الگوي State بهترین گزینه است. این الگو به ما اجازه میدهد هر وضعیت را به عنوان یک کلاس جداگانه پیاده‌سازي کنیم و تغییر وضعیت را به آبجکت‌هاي وضعیت واگذار کنیم.


• روش اعمال:

- یک اینترفیس به نام TicketStateتعریف می‌کنیم که متدي مثل ()handleدارد.
- براي هر وضعیت (Closed ,Resolved ,InProgress ,Assigned ,New) یک کلاس جداگانه می‌سازیم که این اینترفیس را پیاده‌سازي می‌کند.
- کلاس Ticketبه جاي نگهداري یک رشته، یک ارجاع به TicketStateنگه می‌دارد. فراخوانی متد handleدر تیکت، به کلاس وضعیت فعلی واگذار (Delegate) می‌شود.
  <br><br>
### **2. نحوه رسیدگی و پاسخدهی براساس نوع درخواست**

• شرح مسئله: در بخش‌هایی از کد (مثلاً وقتی وضعیت ASSIGNED یا IN_PROGRESS است)، بر اساس نوع تیکت (BUG یا سایر موارد)، واحد مسئول یا نوع پاسخ متفاوت است. در کد فعلی این بررسی با دستور if (type.equals("BUG")) انجام شده است. اگر بخواهیم نوع جدیدي  اضافه کنیم، باید کدهاي اصلی را تغییر دهیم.

• الگوي پیشنهادي: Strategy Patern (الگوي استراتژي) 

• دلیل: وقتی می خواهیم به یک هدف برسیم ولی پیاده سازی و الگوریتم‌های متفاوتی وجود دارند(اینجا روش رسیدگی/پاسخدهی) و باید در زمان اجرا یکی از آن الگوریتم ها را انتخاب کنیم، از الگوي Strategy استفاده می‌کنیم. این کار باعث حذف دستورات شرطی مربوط به نوع تیکت می‌شود.

• روش اعمال:
- یک اینترفیس به نام HandlingStrategy تعریف می‌کنیم که متدهایی براي assign (ارجاع به واحد) و respond (ارسال پاسخ) دارد.
- دو کلاس استراتژي میسازیم: BugHandlingStrategy وGeneralHandlingStrategy

ساختار متدهای اینترفیس HandlingStrategy: برای پوشش کامل چرخه حیات یک تیکت، این اینترفیس دارای دو متد کلیدی است که در مراحل مختلف فراخوانی می‌شوند:<br>
- متد assign() (مرحله ارجاع): <br>
کاربرد: این متد در وضعیت AssignedState فراخوانی می‌شود.<br>
دلیل: هر نوع تیکت باید به واحد مربوطه ارجاع شود. مثلاً در BugHandlingStrategy تیکت به "تیم فنی" و در GeneralHandlingStrategy به "تیم پشتیبانی" ارجاع داده می‌شود. این متد تضمین می‌کند که منطق «به چه کسی ارجاع شود» از کلاس تیکت جدا شود.<br>
- متد respond() (مرحله پاسخ‌دهی): <br>
کاربرد: این متد در وضعیت InProgressState فراخوانی می‌شود.<br>
دلیل: پس از ارجاع دادن به واحد مربوطه، نوع پاسخ به کاربر متفاوت است. برای یک باگ، پاسخ "Sending bug response" است، اما برای درخواست‌های عمومی، پاسخ "Sending generic response" می‌باشد. این متد منطق «چگونه پاسخ داده شود» را مدیریت می‌کند.<br>
<br><br>
### **3. ایجاد آبجکت‌هاي تیکت بر اساس کانال ورودی** 

• شرح مسئله: در کد Main، آبجکت Ticket به صورت مستقیم با new ساخته می‌شود. اگر بخواهیم منطق پیچیده‌اي براي ایجاد تیکت داشته باشیم، یا بخواهیم نوع تیکت را در لحظه ساخت تعیین کنیم، کلاس Main درگیر جزئیات ساخت می‌شود.

• الگوي پیشنهادي: Factory Patern (الگوي کارخانه) 

• دلیل: براي جدا کردن منطق ایجاد آبجکت‌ها از کلاینت و مدیریت پیچیدگی‌هاي ساخت مرحله به مرحله، از الگوي Factory استفاده می‌کنیم. این کار باعث می‌شود کلاینت (Main) نداند چگونه یک تیکت ساخته می‌شود، فقط درخواست می‌دهد.

• روش اعمال:<br>
- یک کلاس TicketFactoryمی سازیم به عنوان مرکز مدیریت عمل می‌کند و با بررسی درخواست کلاینت (نوع کانال)، تصمیم می‌گیرد مسئولیتِ نهاییِ ساخت را به کدام زیرکلاس واگذار کند.<br>
- زیرکلاس‌های WebTicketFactory و EmailTicketFactory: هر کلاس مسئولیتِ نمونه‌سازیِ واقعیِ تیکت را بر عهده دارد.<br>
- چاپ پیام‌های شناسایی (مانند Received from web/email) در Constructor زیرکلاس‌ها قرار گرفته است؛ بنابراین به محض انتخابِ کلاس توسط فکتوری، هویت آن اعلام می‌شود.




# **بخش دوم: ترسیم Class Diagram**



لینک تصویر Class Diagram:

https://github.com/Rzvn-mhmdi/OOD_Assignment2/blob/17ed1289491ffe6d9517323c6012ae96670b86b3/ticket-class-diagram.png

<br><br>
# **بخش سوم: اعمال الگو**



### **۱. پیاده‌سازی الگوی طراحی وضعیت (State Pattern)**

برای مدیریت چرخه حیات تیکت، از اینترفیس TicketState و کلاس‌های پیاده‌ساز آن استفاده شده است:

کد TicketState.java: تعریف یک قرارداد واحد برای تمام وضعیت‌ها با متد handle(Ticket ticket).

کد NewState.java: مسئول چاپ پیام ایجاد تیکت و انتقال به وضعیت AssignedState.

کد AssignedState.java: با استفاده از استراتژی تعیین شده، عمل تخصیص را انجام داده و به وضعیت InProgressState می‌رود.

کد InProgressState.java: عملیات پاسخگویی را از طریق استراتژی اجرا کرده و تیکت را به ResolvedState منتقل می‌کند.

کد ResolvedState.java: پیام Resolvede را چاپ می‌کند و تیکت را به ClosedState منتقل می‌کند. 

کد ClosedState.java: مرحله نهایی که عملیات لاگ‌گیری پایان کار را انجام می‌دهد.

تغییرات در کد Ticket:
در کد قدیمی، نوع تیکت (مثلاً BUG) با شرط‌های ساده بررسی می‌شد.

در کد جدید به جای اینکه تیکت بداند «چگونه» کارها را انجام دهد، یک شیء استراتژی (private HandlingStrategy strategy) را در خود نگه می‌دارد. متد setStrategy به فکتوری اجازه می‌دهد تا در لحظه ساخت، ابزار مناسب (مثلاً BugHandlingStrategy) را به تیکت تزریق کند و متد getStrategy به کلاس‌هایی مثل AssignedState اجازه می‌دهد تا بدون درگیر شدن با نوع تیکت، دستور assign() را از داخل آن استراتژی فراخوانی کنند
<br><br>
### **۲. پیاده‌سازی الگوی طراحی استراتژی (Strategy Pattern)**

تعریف اینترفیس HandlingStrategy با دو متد کلیدی assign, respond:

در کد قدیمی، TicketService باید می‌دانست هر نوع تیکت به کجا ارجاع شود و چه پاسخی بگیرد. با دو متد assign و respond در استراتژی، تیکت خودش می‌داند در هر مرحله چه رفتاری نشان دهد.<br>
متد assign(): برای مدیریت منطق ارجاع تیکت. این متد جایگزین if (type.equals("BUG")) در مرحله ASSIGNED کد قدیمی شد.<br>
متد respond(): برای مدیریت منطق پاسخ‌دهی. این متد جایگزین شرط‌های مربوط به چاپ پیام پاسخ در مرحله IN_PROGRESS شد.


ایجاد کلاس‌های BugHandlingStrategy و GeneralHandlingStrategy:
انتقال پیام‌های چاپی اختصاصی (مثل "Assigned to engineering" یا "Sending bug response") به داخل این کلاس‌ها
<br><br>
### **۳. پیاده‌سازی الگوی طراحی فکتوری (Factory Method)**

ایجاد کلاس TicketFactory:
<br>
کلاس فکتوری به این دلیل اضافه شد که مسئولیت تصمیم‌گیری برای ایجاد اشیاء را از کلاس Main بردارد. با این کار، لایه اجرایی برنامه دیگر درگیر جزئیات ساختار داخلی تیکت‌ها نمی‌شود.

ایجاد زیرکلاس‌های Email/WebTicketFactory:
<br>
این زیرکلاس‌ها وظیفه دارند پس از تصمیم‌گیری فکتوری درباره نوع درخواست، شیء تیکت مربوط به آن کانال را بسازند. همچنین وظیفه چاپ پیام‌های اطلاع‌رسانی (Received from email/web) به این کلاس‌ها واگذار شده است.<br>
کد مربوط به بررسی نوع تیکت type.equalsIgnoreCase("BUG") در هر دو زیرکلاس تکرار شده است تا اطمینان حاصل شود که هر تیکت بلافاصله پس از ساخته شدن، به استراتژی صحیح (Bug/General) تخصیص داده می‌شود تا در مراحل بعدی پردازش (AssignedState و  InProgressState)، تیکت بدون خطا عمل کند.
<br><br>
### **۴. تغییرات در کلاس Main**
برای سازگاری با ساختار جدید و الگوهای طراحی اضافه شده، تغییر زیر در کلاس Main اعمال شد: <br>
نمونه‌سازی مستقیم تیکت با دستور new حذف شد و به جای آن، از متد createTicket در کلاس فکتوری استفاده شد.
<br><br>
# **بخش چهارم: تحلیل شی گرا**
پس از اعمال الگوها، سیستم از نظر OCP و SRP با انتقال منطق شرطی به کلاس‌های تخصصیِ وضعیت و استراتژی به شدت تقویت شده و توسعه‌پذیری آن بدون دستکاری کدهای موجود میسر گشته است. از منظر PLK، وابستگی متقابل کلاس‌ها کاهش یافته و کپسوله‌سازی رفتارها بهتر صورت گرفته است. درست است که تعداد فایل‌ها و کلاس‌های پروژه زیاد شده است، اما در عوض حالا می‌توانیم رفتار تیکت‌ها را در زمان اجرا تغییر دهیم(CRP).
<br>
### **جزئیات بررسی اصول (SOLID + PLK + CRP):** 

**اصل تک مسئولیتی (SRP)** <br>
قبل از اعمال الگو ها: کلاس TicketService هم‌زمان مسئول چاپ پیام ورودی، تشخیص نوع تیکت، و مدیریت وضعیت‌ها بود.<br>
بعد از اعمال الگو ها: مسئولیت چاپ به Constructor فکتوری‌ها، منطق تخصیص به HandlingStrategy و مدیریت وضعیت به TicketState منتقل شد.<br>
تغییر مثبت: هر کلاس فقط یک دلیل برای تغییر دارد.<br>
تغییر منفی: تعداد کلاس‌های پروژه زیاد شده و پیگیری منطق برنامه بین فایل‌های مختلف کمی زمان‌برتر است.

**اصل باز-بسته (OCP)** <br>
قبل از اعمال الگو ها: برای افزودن وضعیت یا نوع تیکت جدید، باید بدنه متد handle در TicketService تغییر می‌کرد و بلوک‌های if-else اضافه می‌شد.<br>
بعد از اعمال الگوها: با الگوهای State و Strategy، منطق به اشیاء مستقل منتقل شد. حالا برای افزودن قابلیت جدید، فقط کلاس جدید اضافه می‌کنیم بدون تغییر در کدهای قبلی.<br>
تغییر مثبت: سیستم بدون تغییر در کدهای تست‌شده قبلی، توسعه می‌یابد.

**اصل جانشینی لیسکوف (LSP)** <br>
قبل از اعمال الگو ها: به دلیل عدم وجود ارث‌بری، این اصل موضوعیت نداشت.<br>
بعداز اعمال الگوها: کلاس Ticket از اینترفیس‌های پدر (TicketState, HandlingStrategy) استفاده می‌کند و هر یک از نمونه های کلاس فرزندان آنها  بدون ایجاد اختلال در رفتار سیستم، جایگزین پدر می‌شوند.

**اصل جداسازی واسط ها (ISP)** <br>
قبل از اعمال الگو ها: به دلیل عدم وجود اینترفیس، این اصل موضوعیت نداشت.<br>
بعد از اعمال الگو ها: به جای یک اینترفیس حجیم، دو اینترفیس تخصصی (TicketState برای وضعیت و HandlingStrategy برای ارجاع و پاسخ دهی) ساخته شد.<br>
تغییر مثبت: کلاس‌هایی مثل NewState مجبور به پیاده‌سازی متدهای نامربوط نیستند.

**اصل معکوس کردن وابستگی (DIP)** <br>
قبل از اعمال الگو ها: کلاس Main مستقیماً از کلاس Ticket (سطح پایین) شیء می‌ساخت و باید تمام جزئیات آن را می‌دانست.<br>
بعد از اعمال الگوها: با ایجاد TicketFactory و زیرکلاس‌های آن، Main دیگر به کلاس Ticket وابسته نیست و فقط با خروجی  TicketFactory کار می‌کند.<br>
تغییر مثبت: کلاینت از جزئیاتِ پیاده‌سازیِ کلاس های سطح پایین جدا شده است.
تغییر منفی (نقض OCP در TicketFactory): از آنجایی که منطق تصمیم‌گیری برای ساخت زیرکلاس‌ها (با استفاده از if-else) به داخل  TicketFactory منتقل شده است، عملاً اصل OCP در کلاس  TicketFactory نقض می‌شود.

**اصل ترجیح واسپاری بر ارث بری (CRP)** <br> 
قبل از اعمال: در کد قدیمی نوع تیکت و وضعیت آن در رشته‌های ثابت (String) قفل شده بود.<br>
بعد از اعمال: به جای استفاده از ارث‌بری‌های پیچیده برای انواع تیکت و وضعیت های آن، از Composition استفاده شده است. کلاس Ticket اکنون اشیاء TicketState و HandlingStrategy را در خود دارد.<br>
تغییر مثبت: این تغییر باعث شده رفتار تیکت در زمان اجرا قابل تغییر باشد.

**اصل کمترین اطلاع (PLK)** <br>
قبل از اعمال الگو ها: کلاس‌های Main و TicketService برای کار با تیکت باید از جزئیات داخلی تیکت خبر می‌داشتند تا بفهمند چطور با آن رفتار کنند.<br>
بعد از اعمال الگو ها: کلاینت فقط متد handle را صدا می‌زند و تیکت خودش با کمک استراتژی و وضعیتی که دارد، کار را انجام می‌دهد.<br>
تغییر مثبت: تعاملات مستقیم کاهش یافته و اشیاء فقط با «دوستان نزدیک» (اینترفیس‌ها) صحبت می‌کنند.<br>
تغییر منفی: به دلیل لایه‌بندی زیاد، دنبال کردن مسیر اجرای کد و پیدا کردن منشاء خطاها برای برنامه‌نویس زمان‌برتر شده است.<br>


